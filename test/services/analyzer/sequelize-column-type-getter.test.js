const Context = require('@forestadmin/context');
const chalk = require('chalk');
const ColumnTypeGetter = require('../../../src/services/schema/update/analyzer/sequelize-column-type-getter');
const SequelizeHelper = require('./helpers/sequelize-helper');
const { DATABASE_URL_MYSQL_MAX, DATABASE_URL_POSTGRESQL_MAX } = require('./helpers/database-urls');

const defaultPlan = require('../../../src/context/plan');

describe('services > column type getter', () => {
  describe('handling `JSON` type', () => {
    it('should work for MySQL and PostgreSQL', async () => {
      expect.assertions(2);
      Context.init(defaultPlan);

      async function getComputedType(databaseUrl, dialect) {
        const sequelizeHelper = new SequelizeHelper();
        const databaseConnection = await sequelizeHelper.connect(databaseUrl);
        await sequelizeHelper.dropAndCreate('json');
        const columnTypeGetter = new ColumnTypeGetter(databaseConnection, 'public');
        const computedType = columnTypeGetter.perform({ type: 'JSON' }, 'object', 'json');

        await sequelizeHelper.drop('json', dialect);
        await sequelizeHelper.close();

        return computedType;
      }

      await expect(getComputedType(DATABASE_URL_MYSQL_MAX, 'mysql')).resolves.toBe('JSON');
      await expect(getComputedType(DATABASE_URL_POSTGRESQL_MAX, 'postgresql')).resolves.toBe(
        'JSON',
      );
    });
  });

  describe('using mysql', () => {
    it('should handle BIT(1) as boolean type', async () => {
      expect.assertions(1);

      Context.init(defaultPlan);
      const sequelizeHelper = new SequelizeHelper();
      const databaseConnection = await sequelizeHelper.connect(DATABASE_URL_MYSQL_MAX);
      await sequelizeHelper.dropAndCreate('customers');
      const columnTypeGetter = new ColumnTypeGetter(databaseConnection, '');
      const computedType = await columnTypeGetter.perform(
        { type: 'BIT(1)' },
        'paying',
        'customers',
      );

      expect(computedType).toBe('BOOLEAN');

      await sequelizeHelper.drop('customers', 'mysql');
      await sequelizeHelper.close();
    });

    it('should handle DECIMAL(11,2) as double type', async () => {
      expect.assertions(1);

      Context.init(defaultPlan);
      const sequelizeHelper = new SequelizeHelper();
      const databaseConnection = await sequelizeHelper.connect(DATABASE_URL_MYSQL_MAX);
      await sequelizeHelper.dropAndCreate('cars');
      const columnTypeGetter = new ColumnTypeGetter(databaseConnection, '');
      const computedType = await columnTypeGetter.perform(
        { type: 'DECIMAL(11,2)' },
        'price',
        'cars',
      );

      expect(computedType).toBe('DOUBLE');

      await sequelizeHelper.drop('cars', 'mysql');
      await sequelizeHelper.close();
    });
  });

  describe('using postgresql', () => {
    it('should not handle BIT(1)', async () => {
      expect.assertions(1);

      Context.init(defaultPlan);
      const sequelizeHelper = new SequelizeHelper();
      const databaseConnection = await sequelizeHelper.connect(DATABASE_URL_POSTGRESQL_MAX);
      await sequelizeHelper.dropAndCreate('customers');
      const columnTypeGetter = new ColumnTypeGetter(databaseConnection, 'public');
      const computedType = await columnTypeGetter.perform(
        { type: 'BIT(1)' },
        'paying',
        'customers',
      );

      expect(computedType).toBeNull();

      await sequelizeHelper.drop('customers', 'postgres');
      await sequelizeHelper.close();
    });

    it('should not handle MONEY type', async () => {
      expect.assertions(2);

      Context.init(defaultPlan);
      const { logger } = Context.inject();
      const warnSpy = jest.spyOn(logger, 'warn').mockImplementation(() => {});
      const sequelizeHelper = new SequelizeHelper();
      const databaseConnection = await sequelizeHelper.connect(DATABASE_URL_POSTGRESQL_MAX);
      await sequelizeHelper.dropAndCreate('customers');
      const columnTypeGetter = new ColumnTypeGetter(databaseConnection, 'public');
      const computedType = await columnTypeGetter.perform({ type: 'MONEY' }, 'paying', 'customers');

      expect(computedType).toBeNull();
      expect(warnSpy).toHaveBeenCalledWith(
        `Type ${chalk.bold('MONEY')} is not handled: The column ${chalk.bold(
          'paying',
        )} won't be generated by Forest CLI. If you need it please create it manually.`,
      );

      await sequelizeHelper.drop('customers', 'postgres');
      await sequelizeHelper.close();
    });

    it('should handle `integer ARRAY` as `ARRAY(DataTypes.INTEGER)`', async () => {
      expect.assertions(1);

      Context.init(defaultPlan);
      const sequelizeHelper = new SequelizeHelper();
      const databaseConnection = await sequelizeHelper.connect(DATABASE_URL_POSTGRESQL_MAX);
      await sequelizeHelper.dropAndCreate('employees');
      const columnTypeGetter = new ColumnTypeGetter(databaseConnection, 'public');
      const computedType = await columnTypeGetter.perform(
        { type: 'ARRAY' },
        'pay_by_quarter',
        'employees',
      );

      expect(computedType).toBe('ARRAY(DataTypes.INTEGER)');

      await sequelizeHelper.drop('employees', 'postgres');
      await sequelizeHelper.close();
    });
  });
});
